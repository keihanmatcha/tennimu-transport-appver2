# -*- coding: utf-8 -*-
"""transport_options12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kkzoqBlegD0CLrWcP6T3IxBVdnobfOsf
"""

import streamlit as st
import pandas as pd

# 会場ファイル構成
files = {
    "大阪①（2025/07/19-20）": {
        "往路1: 東京→新大阪": r"C:\交通費\新幹線　大阪\tokyo_shinosaka_20250719_real_full.csv",
        "往路2: 新大阪→大阪": r"C:\交通費\新幹線　大阪\osaka_shinosaka0719 - コピー.csv",
        "復路1: 大阪→新大阪": r"C:\交通費\新幹線　大阪\shinosaka_osaka0720-コピー.csv",
        "復路2: 新大阪→東京": r"C:\交通費\新幹線　大阪\shinosaka_tokyo_20250720_timetable_fare.csv",
    },
    "大阪②（2025/07/26-27）": {
        "往路1: 東京→新大阪": r"C:\交通費\新幹線　大阪\tokyo_shinosaka_20250726_real_full.csv",
        "往路2: 新大阪→大阪": r"C:\交通費\新幹線　大阪\osaka_shinosaka0726 - コピー.csv",
        "復路1: 大阪→新大阪": r"C:\交通費\新幹線　大阪\shinosaka_osaka0727-コピー.csv",
        "復路2: 新大阪→東京": r"C:\交通費\新幹線　大阪\shinosaka_tokyo_20250727_timetable_fare.csv",
    },
    "岐阜（2025/08/02-03）": {
        "往路1: 東京→名古屋": r"C:\交通費\新幹線　名古屋\tokyo_nozomi_nagoya_fare.csv",
        "往路2: 名古屋→土岐市": r"C:\交通費\新幹線　名古屋\nagoya_tokishi_chuo_20250802.csv",
        "復路1: 土岐市→名古屋": r"C:\交通費\新幹線　名古屋\tokishi_nagoya_custom_textpattern.csv",
        "復路2: 名古屋→東京": r"C:\交通費\新幹線　名古屋\nagoya_tokyo_nozomi_20250803.csv",
    },
    "福岡（2025/08/16-17）": {
        "往路1: 成田空港→福岡空港": r"C:\交通費\hukuoka\20250816naritahukuoka.csv",
        "往路2: 福岡空港→博多": r"C:\交通費\hukuoka\fukuoka_airport_to_hakata_timetable.csv",
        "往路3: 博多→久留米": r"C:\交通費\hukuoka\hakata_to_kurume.csv",
        "復路1: 久留米→博多": r"C:\交通費\hukuoka\kurume_to_hakata.csv",
        "復路2: 博多→福岡空港": r"C:\交通費\hukuoka\hakata_to_fukuoka_airport_timetable.csv",
        "復路3: 福岡空港→成田空港": r"C:\交通費\hukuoka\20250817hukuokanarita.csv",
    },
}

def load_segmented_transport_data(venue_name):
    return files.get(venue_name, {})

def load_and_format_segment_file(path):
    try:
        if path.endswith(".csv"):
          try:
                df = pd.read_csv(path, encoding="utf-8")  # 通常読み込み
          except UnicodeDecodeError:
                df = pd.read_csv(path, encoding="shift_jis")  # Excel保存対応

        else:
          df = pd.read_excel(path)
    except Exception as e:
        print(f"読み込みエラー: {e}")
        return pd.DataFrame()

    for col in ["発時刻", "着時刻", "所要時間", "路線", "行先", "料金"]:
        if col not in df.columns:
            df[col] = ""
    df["料金"] = pd.to_numeric(df["料金"], errors="coerce").fillna(0).astype(int)
    return df

# ==== Streamlit UI ====
st.title("会場別 乗換シミュレーター")

会場 = st.sidebar.selectbox("会場を選択", list(files.keys()))
selected_rows = []
合計金額 = 0

for 区間名, ファイル in load_segmented_transport_data(会場).items():
    st.subheader(f"【{区間名}】")
    df = load_and_format_segment_file(ファイル)
    if df.empty:
        st.warning("読み込み失敗またはデータなし")
        continue

    # 最安便を抽出
    idx_min = df["料金"].idxmin()
    minrow = df.loc[idx_min]
    st.markdown(f"🟢 **最安提案:** {minrow['発時刻']}発 {minrow['路線']} → {minrow['料金']}円")

    # ユーザー選択
    options = df.apply(lambda row: " / ".join(row.values.astype(str)), axis=1)
    user_sel = st.selectbox(f"{区間名} 便を選択", options, key=区間名)
    sel_row = df.iloc[options.tolist().index(user_sel)]
    selected_rows.append(sel_row)
    合計金額 += int(sel_row["料金"])
    st.dataframe(df)

st.markdown(f"## 🚄 **選択合計金額: {合計金額:,}円**")
st.write("### 選択した便リスト")
for row, 区間名 in zip(selected_rows, files[会場].keys()):
    st.write(f"【{区間名}】 {row.to_dict()}")