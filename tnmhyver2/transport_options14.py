# -*- coding: utf-8 -*-
"""transport_options14.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T2GH7yI5hMaInAfZmMNRSJjlUpSsy_dq
"""

from transport_options_sub import load_segmented_transport_data, load_and_format_segment_file
import requests
import streamlit as st
import pandas as pd
import math

# --------------------- ã‚¿ãƒ– UI ã®æ§‹æˆ ---------------------
tab1, tab2, tab3,tab4,tab5 = st.tabs(["1.ãƒ›ãƒ†ãƒ«ãƒ—ãƒ©ãƒ³æ¤œç´¢", "2.äº¤é€šè²»ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼", "3.åˆè¨ˆè²»ç”¨ãƒ©ãƒ³ã‚­ãƒ³ã‚°","4.å®¿æ³Šï¼‹äº¤é€šè²»ã®åˆè¨ˆãƒ©ãƒ³ã‚­ãƒ³ã‚°ï¼ˆé¸æŠãƒ—ãƒ©ãƒ³åæ˜ ï¼‰","ã‚³ã‚¹ãƒˆæ„Ÿåº¦åˆ†æ"])

# --------------------- å…±é€šé–¢æ•° ---------------------
def haversine(lat1, lon1, lat2, lon2):
    R = 6371
    phi1, phi2 = math.radians(lat1), math.radians(lat2)
    d_phi = math.radians(lat2 - lat1)
    d_lambda = math.radians(lon2 - lon1)
    a = math.sin(d_phi/2)**2 + math.cos(phi1)*math.cos(phi2)*math.sin(d_lambda/2)**2
    return R * 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
include_extra_fee = st.sidebar.checkbox("è£œè¶³äº¤é€šè²»ï¼ˆæ–°æµ¦å®‰â†”æ±äº¬ã¾ãŸã¯ãƒªãƒ ã‚¸ãƒ³ãƒã‚¹ï¼‰ã‚’å«ã‚ã‚‹", value=True)

# --------------------- åœ°ç‚¹æƒ…å ± ---------------------
AREAS = [
    {"area_name": "å¤§é˜ªâ‘ ï¼ˆ2025/07/19-20ï¼‰", "params": {"largeClassCode": "japan", "middleClassCode": "osaka", "smallClassCode": "shi", "detailClassCode": "B"}, "checkin": "2025-07-19", "checkout": "2025-07-20", "geo": {"latitude": 34.702485, "longitude": 135.495951}, "venue_geo": {"latitude": 34.700576, "longitude": 135.494031}},
    {"area_name": "å¤§é˜ªâ‘¡ï¼ˆ2025/07/26-27ï¼‰", "params": {"largeClassCode": "japan", "middleClassCode": "osaka", "smallClassCode": "shi", "detailClassCode": "B"}, "checkin": "2025-07-26", "checkout": "2025-07-27", "geo": {"latitude": 34.702485, "longitude": 135.495951}, "venue_geo": {"latitude": 34.700576, "longitude": 135.494031}},
    {"area_name": "å²é˜œï¼ˆ2025/08/02-03ï¼‰", "params": {"largeClassCode": "japan", "middleClassCode": "gihu", "smallClassCode": "tajimi"}, "checkin": "2025-08-02", "checkout": "2025-08-03", "geo": {"latitude": 35.3598779, "longitude": 137.1823884}, "venue_geo": {"latitude": 35.352727, "longitude": 137.184047}},
    {"area_name": "ç¦å²¡ï¼ˆ2025/08/16-17ï¼‰", "params": {"largeClassCode": "japan", "middleClassCode": "hukuoka", "smallClassCode": "kurume"}, "checkin": "2025-08-16", "checkout": "2025-08-17", "geo": {"latitude": 33.316279, "longitude": 130.507795}, "venue_geo": {"latitude": 33.313891, "longitude": 130.513184}}
]

# --------------------- ã‚¿ãƒ–1: ãƒ›ãƒ†ãƒ«ãƒ—ãƒ©ãƒ³æ¤œç´¢ ---------------------
with tab1:
    st.header("ãƒ›ãƒ†ãƒ«ãƒ—ãƒ©ãƒ³æ¤œç´¢")
    APP_ID = st.secrets["RAKUTEN_TRAVEL_API_KEY"]

    st.sidebar.header("ã“ã ã‚ã‚Šæ¡ä»¶")
    squeeze_keys = [k for k, v in zip(["kinen", "internet", "daiyoku", "onsen", "breakfast", "dinner"], [
        st.sidebar.checkbox("ç¦ç…™", value=True),
        st.sidebar.checkbox("ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆ"),
        st.sidebar.checkbox("å¤§æµ´å ´"),
        st.sidebar.checkbox("æ¸©æ³‰"),
        st.sidebar.checkbox("æœé£Ÿä»˜ã"),
        st.sidebar.checkbox("å¤•é£Ÿä»˜ã")
    ]) if v]
    squeeze_condition = ",".join(squeeze_keys)

    keyword_filter = {
        "course": st.sidebar.checkbox("ã‚³ãƒ¼ã‚¹"),
        "washoku": st.sidebar.checkbox("å’Œé£Ÿ"),
        "buffet": st.sidebar.checkbox("ãƒ“ãƒ¥ãƒƒãƒ•ã‚§")
    }

    room_filter = {
        "japanese": st.sidebar.checkbox("å’Œå®¤"),
        "western": st.sidebar.checkbox("æ´‹å®¤")
    }

    review_threshold = st.sidebar.selectbox("å£ã‚³ãƒŸè©•ä¾¡ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼", ["æŒ‡å®šãªã—", "3.0ä»¥ä¸Š", "3.5ä»¥ä¸Š", "4.0ä»¥ä¸Š", "4.5ä»¥ä¸Š"], index=0)
    review_threshold = float(review_threshold.replace("ä»¥ä¸Š", "")) if review_threshold != "æŒ‡å®šãªã—" else None

    radius = st.sidebar.radio("è·é›¢æ¡ä»¶", [None, 0.5, 1.0, 2.0, 3.0], index=2)
    location_priority = st.sidebar.radio("è·é›¢ã®å„ªå…ˆé †ä½", ["é§…ã«è¿‘ã„", "ä¼šå ´ã«è¿‘ã„", "ä¸¡æ–¹ã«è¿‘ã„"], index=2)

    if st.button("æ¤œç´¢é–‹å§‹"):
        all_area_results = []
        with st.spinner("æ¤œç´¢ä¸­..."):
            for area in AREAS:
                st.subheader(area["area_name"])
                params = {
                    "applicationId": APP_ID,
                    "format": "json",
                    "checkinDate": area["checkin"],
                    "checkoutDate": area["checkout"],
                    "roomNum": 1,
                    "adultNum": 1
                }
                params.update(area["params"])
                if squeeze_condition:
                    params["squeezeCondition"] = squeeze_condition

                res = requests.get("https://app.rakuten.co.jp/services/api/Travel/VacantHotelSearch/20170426", params=params)
                if res.status_code != 200:
                    st.warning("APIã‚¨ãƒ©ãƒ¼")
                    continue

                hotels = res.json().get("hotels", [])
                plans = []
                for hotel in hotels:
                    info = hotel["hotel"][0]["hotelBasicInfo"]
                    rooms = hotel["hotel"][1].get("roomInfo", [])
                    for i in range(0, len(rooms), 2):
                        basic = rooms[i].get("roomBasicInfo", {})
                        price = rooms[i + 1].get("dailyCharge", {}).get("total")
                        name = basic.get("roomName", "")
                        if price is None:
                            continue
                        if room_filter["japanese"] and "å’Œå®¤" not in name:
                            continue
                        if room_filter["western"] and not any(k in name for k in ["æ´‹å®¤", "ã‚·ãƒ³ã‚°ãƒ«", "ãƒ„ã‚¤ãƒ³", "ãƒ€ãƒ–ãƒ«", "ã‚»ãƒŸãƒ€ãƒ–ãƒ«"]):
                            continue
                        if review_threshold:
                            try:
                                if float(info.get("reviewAverage", 0)) < review_threshold:
                                    continue
                            except:
                                continue
                        plan = {
                            "ä¼šå ´": area["area_name"],
                            "ãƒ›ãƒ†ãƒ«å": info.get("hotelName"),
                            "ä½æ‰€": info.get("address1", "") + info.get("address2", ""),
                            "è©•ä¾¡": info.get("reviewAverage", "N/A"),
                            "ãƒ—ãƒ©ãƒ³": basic.get("planName", "ãƒ—ãƒ©ãƒ³åä¸æ˜"),
                            "æ–™é‡‘": int(price),
                            "äºˆç´„URL": basic.get("reserveUrl")
                        }
                        plans.append(plan)
                if plans:
                    df = pd.DataFrame(plans).sort_values("æ–™é‡‘")
                    df["äºˆç´„URL"] = df["äºˆç´„URL"].apply(lambda x: f"[äºˆç´„]({x})")
                    st.dataframe(df)
                    all_area_results.append((area["area_name"], df))

            if squeeze_keys:
                st.markdown("## ğŸ’¡ æ¡ä»¶ã‚’1ã¤å¤–ã—ãŸã¨ãã®ä¾¡æ ¼æ¯”è¼ƒ")
                for key in squeeze_keys:
                    relaxed = ",".join(k for k in squeeze_keys if k != key)
                    relaxed_prices = []
                    for area in AREAS:
                        p = {
                            "applicationId": APP_ID,
                            "format": "json",
                            "checkinDate": area["checkin"],
                            "checkoutDate": area["checkout"],
                            "roomNum": 1,
                            "adultNum": 1,
                            "squeezeCondition": relaxed,
                        }
                        p.update(area["params"])
                        r = requests.get("https://app.rakuten.co.jp/services/api/Travel/VacantHotelSearch/20170426", params=p)
                        if r.status_code != 200:
                            continue
                        hotels = r.json().get("hotels", [])
                        min_price = float("inf")
                        for hotel in hotels:
                            info = hotel["hotel"][0]["hotelBasicInfo"]
                            rooms = hotel["hotel"][1].get("roomInfo", [])
                            for i in range(0, len(rooms), 2):
                                price = rooms[i + 1].get("dailyCharge", {}).get("total")
                                if price and int(price) < min_price:
                                    min_price = int(price)
                        if min_price < float("inf"):
                            relaxed_prices.append({"ä¼šå ´": area["area_name"], "æ¡ä»¶": f"{key}é™¤å¤–", "æœ€å®‰å€¤": min_price})
                    if relaxed_prices:
                        st.dataframe(pd.DataFrame(relaxed_prices))
              st.session_state["relaxed_price_diffs"] = all_relaxed_prices  # â†è¿½åŠ 

        if all_area_results:
            st.markdown("## ğŸ¨ å…¨ä¼šå ´ã®æ¡ä»¶ã«åˆã£ãŸãƒ›ãƒ†ãƒ«ä¸€è¦§ï¼ˆçµ±åˆè¡¨ç¤ºï¼‰")
            all_combined_df = pd.concat([df for _, df in all_area_results], ignore_index=True)
            all_combined_df = all_combined_df.sort_values("æ–™é‡‘", ascending=True)
            st.dataframe(all_combined_df)
            # â–¼ ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä¼šå ´ã”ã¨ã«1ã¤ãƒ›ãƒ†ãƒ«ãƒ—ãƒ©ãƒ³ã‚’é¸ã¹ã‚‹ã‚ˆã†ã«ã™ã‚‹
            st.markdown("## âœ… ä¼šå ´ã”ã¨ã®ãƒ›ãƒ†ãƒ«ãƒ—ãƒ©ãƒ³ã‚’1ã¤ãšã¤é¸æŠ")
            selected_hotel_plans = {}
            for area, df in all_area_results:
                st.subheader(f"{area} ã®ãƒ›ãƒ†ãƒ«ãƒ—ãƒ©ãƒ³ã‚’é¸ã‚“ã§ãã ã•ã„")
                options = df["ãƒ›ãƒ†ãƒ«å"] + "ï¼ˆ" + df["ãƒ—ãƒ©ãƒ³"] + f"ï¼‰Â¥" + df["æ–™é‡‘"].astype(str)
                selected = st.selectbox("é¸æŠã—ã¦ãã ã•ã„", options.tolist(), key=f"hotel_{area}")
                selected_row = df.iloc[options.tolist().index(selected)]
                selected_hotel_plans[area] = selected_row
            # session_state ã«ä¿å­˜
            st.session_state["selected_hotel_plans"] = selected_hotel_plans


# --------------------- ã‚¿ãƒ–2: äº¤é€šè²»ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ ---------------------
with tab2:
    st.header("äº¤é€šæ‰‹æ®µã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼")
    venue = st.sidebar.selectbox("ä¼šå ´ã‚’é¸æŠ", [a["area_name"] for a in AREAS])
    segments = load_segmented_transport_data(venue)

    total_price = 0
    selected_rows = []

    for section, path in segments.items():
        st.subheader(f"ã€{section}ã€‘")
        df = load_and_format_segment_file(path)
        if df.empty:
            st.warning("ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å¤±æ•—")
            continue
        options = df.apply(lambda r: " / ".join(r.values.astype(str)), axis=1)
        selected = st.selectbox(f"{section} ã®ä¾¿ã‚’é¸ã‚“ã§ãã ã•ã„", options, key=section)
        row = df.iloc[options.tolist().index(selected)]
        selected_rows.append(row)
        total_price += row["æ–™é‡‘"]
    if include_extra_fee:
        if "ç¦å²¡" in venue:
            total_price += 4600  # ãƒªãƒ ã‚¸ãƒ³ãƒã‚¹å¾€å¾©
        elif "å¤§é˜ª" in venue or "å²é˜œ" in venue:
            total_price += 640   # æ–°æµ¦å®‰â†’æ±äº¬ å¾€å¾©
    st.markdown(f"### åˆè¨ˆäº¤é€šè²»: Â¥{total_price:,}")
    for section, row in zip(segments.keys(), selected_rows):
        st.write(f"ã€{section}ã€‘", row.to_dict())

# --------------------- ã‚¿ãƒ–3: å®¿æ³Šï¼‹äº¤é€šè²»ã®åˆè¨ˆè²»ç”¨ãƒ©ãƒ³ã‚­ãƒ³ã‚° ---------------------
with tab3:
    st.header("å®¿æ³Šï¼‹äº¤é€šè²»ã®åˆè¨ˆãƒ©ãƒ³ã‚­ãƒ³ã‚°")
    ranking = []
    for area in AREAS:
        hotel_params = {
            "applicationId": APP_ID,
            "format": "json",
            "checkinDate": area["checkin"],
            "checkoutDate": area["checkout"],
            "roomNum": 1,
            "adultNum": 1
        }
        hotel_params.update(area["params"])
        res = requests.get("https://app.rakuten.co.jp/services/api/Travel/VacantHotelSearch/20170426", params=hotel_params)
        if res.status_code != 200:
            continue
        hotels = res.json().get("hotels", [])
        min_price = float("inf")
        for hotel in hotels:
            rooms = hotel["hotel"][1].get("roomInfo", [])
            for i in range(0, len(rooms), 2):
                price = rooms[i + 1].get("dailyCharge", {}).get("total")
                if price and int(price) < min_price:
                    min_price = int(price)
        segments = load_segmented_transport_data(area["area_name"])
        total_trans = 0
        for path in segments.values():
            df = load_and_format_segment_file(path)
            if not df.empty:
                total_trans += df["æ–™é‡‘"].min()
            if include_extra_fee:
                if "ç¦å²¡" in area["area_name"]:
                    total_trans += 4600
                else:
                    total_trans += 640

        if min_price < float("inf"):
            ranking.append({"ä¼šå ´": area["area_name"], "å®¿æ³Šè²»": min_price, "äº¤é€šè²»": total_trans, "åˆè¨ˆ": min_price + total_trans})
    if ranking:
        df = pd.DataFrame(ranking).sort_values("åˆè¨ˆ")
        st.dataframe(df)
    else:
        st.info("ãƒ©ãƒ³ã‚­ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚")
# ã‚¿ãƒ–4: å®¿æ³Šï¼‹äº¤é€šè²»ã®åˆè¨ˆãƒ©ãƒ³ã‚­ãƒ³ã‚°ï¼ˆé¸æŠæ¸ˆã¿ãƒ›ãƒ†ãƒ«ãƒ—ãƒ©ãƒ³ã¨é€£å‹•ï¼‰
with tab4:
    st.header("å®¿æ³Šï¼‹äº¤é€šè²»ã®åˆè¨ˆãƒ©ãƒ³ã‚­ãƒ³ã‚°ï¼ˆé¸æŠãƒ—ãƒ©ãƒ³åæ˜ ï¼‰")
    combined_ranking = []
    selected_hotel_plans = st.session_state.get("selected_hotel_plans", {})
    for area in AREAS:
        area_name = area["area_name"]
        if area_name not in selected_hotel_plans:
            continue

        # å®¿æ³Šè²»ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒé¸ã‚“ã ãƒ—ãƒ©ãƒ³ï¼‰
        selected_plan = selected_hotel_plans[area_name]
        hotel_cost = int(selected_plan["æ–™é‡‘"])

        # äº¤é€šè²»æœ€å®‰å€¤ã®å–å¾—
        segments = load_segmented_transport_data(area_name)
        transport_cost = 0
        for path in segments.values():
            df = load_and_format_segment_file(path)
            if not df.empty:
                transport_cost += df["æ–™é‡‘"].min()

        # è£œè¶³äº¤é€šè²»ã‚’å«ã‚ã‚‹ã‹
        if include_extra_fee:
            if "ç¦å²¡" in area_name:
                transport_cost += 4600
            elif "å¤§é˜ª" in area_name or "å²é˜œ" in area_name:
                transport_cost += 640

        combined_ranking.append({
            "ä¼šå ´": area_name,
            "ãƒ›ãƒ†ãƒ«å": selected_plan["ãƒ›ãƒ†ãƒ«å"],
            "å®¿æ³Šè²»": hotel_cost,
            "äº¤é€šè²»": transport_cost,
            "åˆè¨ˆ": hotel_cost + transport_cost,
            "äºˆç´„": selected_plan["äºˆç´„URL"]
        })

    if combined_ranking:
        df = pd.DataFrame(combined_ranking).sort_values("åˆè¨ˆ")
        df["äºˆç´„"] = df["äºˆç´„"].apply(lambda x: f"[ãƒªãƒ³ã‚¯]({x})")
        st.dataframe(df)
    else:
        st.info("ãƒ›ãƒ†ãƒ«ãƒ—ãƒ©ãƒ³ãŒæœªé¸æŠã®ä¼šå ´ãŒã‚ã‚Šã¾ã™ã€‚")

with tab5:
    st.header("ã‚³ã‚¹ãƒˆæ„Ÿåº¦åˆ†æ")
    st.markdown("### ğŸ” æ¡ä»¶ç·©å’Œã«ã‚ˆã‚‹ä¾¡æ ¼å·®ã®å¯è¦–åŒ–ï¼ˆæ„Ÿåº¦åˆ†æï¼‰")

    # ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿å–ã‚‹
    relaxed_data = st.session_state.get("relaxed_price_diffs", [])

    if not relaxed_data:
        st.info("tab1ã§ãƒ›ãƒ†ãƒ«æ¤œç´¢ã‚’è¡Œã„ã€ã“ã ã‚ã‚Šæ¡ä»¶ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚")
    else:
        df = pd.DataFrame(relaxed_data)
        pivot_df = df.pivot(index="ä¼šå ´", columns="æ¡ä»¶", values="ä¾¡æ ¼å·®")

        st.markdown("#### ğŸ“Š å„æ¡ä»¶ã‚’ç·©å’Œã—ãŸã¨ãã®æœ€å®‰ä¾¡æ ¼ï¼ˆå††ï¼‰")
        st.dataframe(pivot_df.style.format("{:.0f} å††"))

        import seaborn as sns
        import matplotlib.pyplot as plt

        fig, ax = plt.subplots(figsize=(8, 6))
        sns.heatmap(pivot_df, annot=True, fmt=".0f", cmap="Reds", linewidths=0.5, ax=ax)
        ax.set_title("ã“ã ã‚ã‚Šæ¡ä»¶ãŒä¾¡æ ¼ã«ä¸ãˆã‚‹å½±éŸ¿ï¼ˆæ„Ÿåº¦ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ï¼‰")
        st.pyplot(fig)

        st.markdown("ğŸ’¡ èµ¤ã„ã»ã©ä¾¡æ ¼ã‚’æŠ¼ã—ä¸Šã’ã¦ã„ã‚‹æ¡ä»¶ã§ã™ã€‚")