# -*- coding: utf-8 -*-
"""transport_options14.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T2GH7yI5hMaInAfZmMNRSJjlUpSsy_dq
"""

from transport_options_sub import load_segmented_transport_data, load_and_format_segment_file
import requests
import streamlit as st
import pandas as pd
import math

# --------------------- タブ UI の構成 ---------------------
tab1, tab2, tab3,tab4,tab5 = st.tabs(["1.ホテルプラン検索", "2.交通費セレクター", "3.合計費用ランキング","4.宿泊＋交通費の合計ランキング（選択プラン反映）","コスト感度分析"])

# --------------------- 共通関数 ---------------------
def haversine(lat1, lon1, lat2, lon2):
    R = 6371
    phi1, phi2 = math.radians(lat1), math.radians(lat2)
    d_phi = math.radians(lat2 - lat1)
    d_lambda = math.radians(lon2 - lon1)
    a = math.sin(d_phi/2)**2 + math.cos(phi1)*math.cos(phi2)*math.sin(d_lambda/2)**2
    return R * 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
include_extra_fee = st.sidebar.checkbox("補足交通費（新浦安↔東京またはリムジンバス）を含める", value=True)

# --------------------- 地点情報 ---------------------
AREAS = [
    {"area_name": "大阪①（2025/07/19-20）", "params": {"largeClassCode": "japan", "middleClassCode": "osaka", "smallClassCode": "shi", "detailClassCode": "B"}, "checkin": "2025-07-19", "checkout": "2025-07-20", "geo": {"latitude": 34.702485, "longitude": 135.495951}, "venue_geo": {"latitude": 34.700576, "longitude": 135.494031}},
    {"area_name": "大阪②（2025/07/26-27）", "params": {"largeClassCode": "japan", "middleClassCode": "osaka", "smallClassCode": "shi", "detailClassCode": "B"}, "checkin": "2025-07-26", "checkout": "2025-07-27", "geo": {"latitude": 34.702485, "longitude": 135.495951}, "venue_geo": {"latitude": 34.700576, "longitude": 135.494031}},
    {"area_name": "岐阜（2025/08/02-03）", "params": {"largeClassCode": "japan", "middleClassCode": "gihu", "smallClassCode": "tajimi"}, "checkin": "2025-08-02", "checkout": "2025-08-03", "geo": {"latitude": 35.3598779, "longitude": 137.1823884}, "venue_geo": {"latitude": 35.352727, "longitude": 137.184047}},
    {"area_name": "福岡（2025/08/16-17）", "params": {"largeClassCode": "japan", "middleClassCode": "hukuoka", "smallClassCode": "kurume"}, "checkin": "2025-08-16", "checkout": "2025-08-17", "geo": {"latitude": 33.316279, "longitude": 130.507795}, "venue_geo": {"latitude": 33.313891, "longitude": 130.513184}}
]

# --------------------- タブ1: ホテルプラン検索 ---------------------
with tab1:
    st.header("ホテルプラン検索")
    APP_ID = st.secrets["RAKUTEN_TRAVEL_API_KEY"]

    st.sidebar.header("こだわり条件")
    squeeze_keys = [k for k, v in zip(["kinen", "internet", "daiyoku", "onsen", "breakfast", "dinner"], [
        st.sidebar.checkbox("禁煙", value=True),
        st.sidebar.checkbox("インターネット"),
        st.sidebar.checkbox("大浴場"),
        st.sidebar.checkbox("温泉"),
        st.sidebar.checkbox("朝食付き"),
        st.sidebar.checkbox("夕食付き")
    ]) if v]
    squeeze_condition = ",".join(squeeze_keys)

    keyword_filter = {
        "course": st.sidebar.checkbox("コース"),
        "washoku": st.sidebar.checkbox("和食"),
        "buffet": st.sidebar.checkbox("ビュッフェ")
    }

    room_filter = {
        "japanese": st.sidebar.checkbox("和室"),
        "western": st.sidebar.checkbox("洋室")
    }

    review_threshold = st.sidebar.selectbox("口コミ評価フィルター", ["指定なし", "3.0以上", "3.5以上", "4.0以上", "4.5以上"], index=0)
    review_threshold = float(review_threshold.replace("以上", "")) if review_threshold != "指定なし" else None

    radius = st.sidebar.radio("距離条件", [None, 0.5, 1.0, 2.0, 3.0], index=2)
    location_priority = st.sidebar.radio("距離の優先順位", ["駅に近い", "会場に近い", "両方に近い"], index=2)

    if st.button("検索開始"):
        all_area_results = []
        with st.spinner("検索中..."):
            for area in AREAS:
                st.subheader(area["area_name"])
                params = {
                    "applicationId": APP_ID,
                    "format": "json",
                    "checkinDate": area["checkin"],
                    "checkoutDate": area["checkout"],
                    "roomNum": 1,
                    "adultNum": 1
                }
                params.update(area["params"])
                if squeeze_condition:
                    params["squeezeCondition"] = squeeze_condition

                res = requests.get("https://app.rakuten.co.jp/services/api/Travel/VacantHotelSearch/20170426", params=params)
                if res.status_code != 200:
                    st.warning("APIエラー")
                    continue

                hotels = res.json().get("hotels", [])
                plans = []
                for hotel in hotels:
                    info = hotel["hotel"][0]["hotelBasicInfo"]
                    rooms = hotel["hotel"][1].get("roomInfo", [])
                    for i in range(0, len(rooms), 2):
                        basic = rooms[i].get("roomBasicInfo", {})
                        price = rooms[i + 1].get("dailyCharge", {}).get("total")
                        name = basic.get("roomName", "")
                        if price is None:
                            continue
                        if room_filter["japanese"] and "和室" not in name:
                            continue
                        if room_filter["western"] and not any(k in name for k in ["洋室", "シングル", "ツイン", "ダブル", "セミダブル"]):
                            continue
                        if review_threshold:
                            try:
                                if float(info.get("reviewAverage", 0)) < review_threshold:
                                    continue
                            except:
                                continue
                        plan = {
                            "会場": area["area_name"],
                            "ホテル名": info.get("hotelName"),
                            "住所": info.get("address1", "") + info.get("address2", ""),
                            "評価": info.get("reviewAverage", "N/A"),
                            "プラン": basic.get("planName", "プラン名不明"),
                            "料金": int(price),
                            "予約URL": basic.get("reserveUrl")
                        }
                        plans.append(plan)
                if plans:
                    df = pd.DataFrame(plans).sort_values("料金")
                    df["予約URL"] = df["予約URL"].apply(lambda x: f"[予約]({x})")
                    st.dataframe(df)
                    all_area_results.append((area["area_name"], df))

            if squeeze_keys:
                st.markdown("## 💡 条件を1つ外したときの価格比較")
                for key in squeeze_keys:
                    relaxed = ",".join(k for k in squeeze_keys if k != key)
                    relaxed_prices = []
                    for area in AREAS:
                        p = {
                            "applicationId": APP_ID,
                            "format": "json",
                            "checkinDate": area["checkin"],
                            "checkoutDate": area["checkout"],
                            "roomNum": 1,
                            "adultNum": 1,
                            "squeezeCondition": relaxed,
                        }
                        p.update(area["params"])
                        r = requests.get("https://app.rakuten.co.jp/services/api/Travel/VacantHotelSearch/20170426", params=p)
                        if r.status_code != 200:
                            continue
                        hotels = r.json().get("hotels", [])
                        min_price = float("inf")
                        for hotel in hotels:
                            info = hotel["hotel"][0]["hotelBasicInfo"]
                            rooms = hotel["hotel"][1].get("roomInfo", [])
                            for i in range(0, len(rooms), 2):
                                price = rooms[i + 1].get("dailyCharge", {}).get("total")
                                if price and int(price) < min_price:
                                    min_price = int(price)
                        if min_price < float("inf"):
                            relaxed_prices.append({"会場": area["area_name"], "条件": f"{key}除外", "最安値": min_price})
                    if relaxed_prices:
                        st.dataframe(pd.DataFrame(relaxed_prices))
              st.session_state["relaxed_price_diffs"] = all_relaxed_prices  # ←追加

        if all_area_results:
            st.markdown("## 🏨 全会場の条件に合ったホテル一覧（統合表示）")
            all_combined_df = pd.concat([df for _, df in all_area_results], ignore_index=True)
            all_combined_df = all_combined_df.sort_values("料金", ascending=True)
            st.dataframe(all_combined_df)
            # ▼ ユーザーが会場ごとに1つホテルプランを選べるようにする
            st.markdown("## ✅ 会場ごとのホテルプランを1つずつ選択")
            selected_hotel_plans = {}
            for area, df in all_area_results:
                st.subheader(f"{area} のホテルプランを選んでください")
                options = df["ホテル名"] + "（" + df["プラン"] + f"）¥" + df["料金"].astype(str)
                selected = st.selectbox("選択してください", options.tolist(), key=f"hotel_{area}")
                selected_row = df.iloc[options.tolist().index(selected)]
                selected_hotel_plans[area] = selected_row
            # session_state に保存
            st.session_state["selected_hotel_plans"] = selected_hotel_plans


# --------------------- タブ2: 交通費セレクター ---------------------
with tab2:
    st.header("交通手段セレクター")
    venue = st.sidebar.selectbox("会場を選択", [a["area_name"] for a in AREAS])
    segments = load_segmented_transport_data(venue)

    total_price = 0
    selected_rows = []

    for section, path in segments.items():
        st.subheader(f"【{section}】")
        df = load_and_format_segment_file(path)
        if df.empty:
            st.warning("データ読み込み失敗")
            continue
        options = df.apply(lambda r: " / ".join(r.values.astype(str)), axis=1)
        selected = st.selectbox(f"{section} の便を選んでください", options, key=section)
        row = df.iloc[options.tolist().index(selected)]
        selected_rows.append(row)
        total_price += row["料金"]
    if include_extra_fee:
        if "福岡" in venue:
            total_price += 4600  # リムジンバス往復
        elif "大阪" in venue or "岐阜" in venue:
            total_price += 640   # 新浦安→東京 往復
    st.markdown(f"### 合計交通費: ¥{total_price:,}")
    for section, row in zip(segments.keys(), selected_rows):
        st.write(f"【{section}】", row.to_dict())

# --------------------- タブ3: 宿泊＋交通費の合計費用ランキング ---------------------
with tab3:
    st.header("宿泊＋交通費の合計ランキング")
    ranking = []
    for area in AREAS:
        hotel_params = {
            "applicationId": APP_ID,
            "format": "json",
            "checkinDate": area["checkin"],
            "checkoutDate": area["checkout"],
            "roomNum": 1,
            "adultNum": 1
        }
        hotel_params.update(area["params"])
        res = requests.get("https://app.rakuten.co.jp/services/api/Travel/VacantHotelSearch/20170426", params=hotel_params)
        if res.status_code != 200:
            continue
        hotels = res.json().get("hotels", [])
        min_price = float("inf")
        for hotel in hotels:
            rooms = hotel["hotel"][1].get("roomInfo", [])
            for i in range(0, len(rooms), 2):
                price = rooms[i + 1].get("dailyCharge", {}).get("total")
                if price and int(price) < min_price:
                    min_price = int(price)
        segments = load_segmented_transport_data(area["area_name"])
        total_trans = 0
        for path in segments.values():
            df = load_and_format_segment_file(path)
            if not df.empty:
                total_trans += df["料金"].min()
            if include_extra_fee:
                if "福岡" in area["area_name"]:
                    total_trans += 4600
                else:
                    total_trans += 640

        if min_price < float("inf"):
            ranking.append({"会場": area["area_name"], "宿泊費": min_price, "交通費": total_trans, "合計": min_price + total_trans})
    if ranking:
        df = pd.DataFrame(ranking).sort_values("合計")
        st.dataframe(df)
    else:
        st.info("ランキングデータが取得できませんでした。")
# タブ4: 宿泊＋交通費の合計ランキング（選択済みホテルプランと連動）
with tab4:
    st.header("宿泊＋交通費の合計ランキング（選択プラン反映）")
    combined_ranking = []
    selected_hotel_plans = st.session_state.get("selected_hotel_plans", {})
    for area in AREAS:
        area_name = area["area_name"]
        if area_name not in selected_hotel_plans:
            continue

        # 宿泊費（ユーザーが選んだプラン）
        selected_plan = selected_hotel_plans[area_name]
        hotel_cost = int(selected_plan["料金"])

        # 交通費最安値の取得
        segments = load_segmented_transport_data(area_name)
        transport_cost = 0
        for path in segments.values():
            df = load_and_format_segment_file(path)
            if not df.empty:
                transport_cost += df["料金"].min()

        # 補足交通費を含めるか
        if include_extra_fee:
            if "福岡" in area_name:
                transport_cost += 4600
            elif "大阪" in area_name or "岐阜" in area_name:
                transport_cost += 640

        combined_ranking.append({
            "会場": area_name,
            "ホテル名": selected_plan["ホテル名"],
            "宿泊費": hotel_cost,
            "交通費": transport_cost,
            "合計": hotel_cost + transport_cost,
            "予約": selected_plan["予約URL"]
        })

    if combined_ranking:
        df = pd.DataFrame(combined_ranking).sort_values("合計")
        df["予約"] = df["予約"].apply(lambda x: f"[リンク]({x})")
        st.dataframe(df)
    else:
        st.info("ホテルプランが未選択の会場があります。")

with tab5:
    st.header("コスト感度分析")
    st.markdown("### 🔍 条件緩和による価格差の可視化（感度分析）")

    # セッションからデータを読み取る
    relaxed_data = st.session_state.get("relaxed_price_diffs", [])

    if not relaxed_data:
        st.info("tab1でホテル検索を行い、こだわり条件を指定してください。")
    else:
        df = pd.DataFrame(relaxed_data)
        pivot_df = df.pivot(index="会場", columns="条件", values="価格差")

        st.markdown("#### 📊 各条件を緩和したときの最安価格（円）")
        st.dataframe(pivot_df.style.format("{:.0f} 円"))

        import seaborn as sns
        import matplotlib.pyplot as plt

        fig, ax = plt.subplots(figsize=(8, 6))
        sns.heatmap(pivot_df, annot=True, fmt=".0f", cmap="Reds", linewidths=0.5, ax=ax)
        ax.set_title("こだわり条件が価格に与える影響（感度ヒートマップ）")
        st.pyplot(fig)

        st.markdown("💡 赤いほど価格を押し上げている条件です。")